<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æå¡çš®å·´æ‹‰ - è»Ÿï¼±å¯¦é«”ç‰ˆ</title>
    <link rel="icon" href="icon.png" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: sans-serif;
        }
        #background-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: background-image 0.5s ease;
        }
        #ar-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: -2;
            transform: scaleX(-1);
            display: none;
        }
        #steam-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(2px);
            pointer-events: none;
            z-index: 1;
            display: none;
        }
        #video-preview-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #fbbf24;
            border-radius: 12px;
            overflow: hidden;
            z-index: 100;
            transform: scaleX(-1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: none;
        }
        #game-canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            position: relative;
            z-index: 10;
        }
        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 110;
        }
        .status-card {
            background: rgba(41, 37, 36, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            border-left: 6px solid #fbbf24;
            pointer-events: auto;
            max-width: 320px;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .control-group {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        select, button {
            background: #44403c;
            color: #fde68a;
            border: 1px solid #57534e;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        select:hover, button:hover {
            background: #57534e;
        }
        #info-tag {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            padding: 8px 16px;
            border-radius: 20px;
            font-family: monospace;
            color: #fbbf24;
            z-index: 110;
            transition: opacity 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        #start-camera-btn {
            background: #fbbf24;
            color: #1c1917;
            font-weight: bold;
            padding: 12px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(251, 191, 36, 0); }
            100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0); }
        }
        .ui-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            transform: translateX(-20px);
        }
        #show-ui-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 120;
            background: rgba(41, 37, 36, 0.8);
            color: #fbbf24;
            border: 1px solid #fbbf24;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
            cursor: pointer;
        }
        #bandaid-btn { background: #fde68a; color: #854d0e; font-weight: bold; }
        #add-capybara-btn { background: #4ade80; color: #064e3b; font-weight: bold; }
        #eat-btn { background: #f87171; color: #7f1d1d; font-weight: bold; }
        
        footer {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            z-index: 110;
            color: rgba(255,255,255,0.7);
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            transition: opacity 0.3s ease;
        }
        footer a { color: #fbbf24; text-decoration: none; font-weight: bold; }
    </style>
</head>
<body>

    <div id="background-layer"></div>
    <video id="ar-video" autoplay playsinline></video>
    <div id="steam-overlay"></div>

    <button id="show-ui-btn">é¡¯ç¤ºé¸å–®</button>

    <div class="ui-overlay" id="main-ui">
        <div class="status-card" id="control-card">
            <h1 class="text-xl font-bold text-amber-400 mb-1">æå¡çš®å·´æ‹‰</h1>
            
            <div id="camera-setup-area" class="mb-3">
                <label class="text-xs block mb-1 text-amber-100">é¸æ“‡æ”å½±æ©Ÿï¼š</label>
                <select id="camera-select" class="w-full mb-2">
                    <option value="">æ­£åœ¨è¼‰å…¥é¡é ­...</option>
                </select>
                <button id="start-camera-btn" class="w-full rounded-lg">å•Ÿå‹•æ”å½±æ©Ÿ</button>
            </div>

            <div class="instruction-box bg-orange-900/20 p-2 rounded-lg border border-orange-500/30 mb-2">
                <p class="text-xs font-bold text-orange-200 mb-1">ç‰©ç†ç­†è¨˜ï¼š</p>
                <div class="text-[11px] text-orange-100">â— è»Ÿï¼±å¯¦é«”ï¼šç¾åœ¨å¯ä»¥å£“æ‰æ‹‰é•·ï¼Œä¸”èƒ½ç©©å®šå †ç–Š</div>
                <div class="text-[11px] text-orange-100">â— æè‡‰ï¼šç”¨æ‰‹æä½é‚Šç·£ç²’å­å³å¯æ‹‰æ‰¯å½¢è®Š</div>
                <div class="text-[11px] text-orange-100">â— æ”¯æ’ï¼šå…§éƒ¨æœ‰ç¡¬æ ¸æ”¯æ’ï¼Œç–Šé«˜é«˜ä¸å†é‡ç–Š</div>
            </div>
            
            <div class="control-group">
                <button id="add-capybara-btn">âœ¨ æ–°å¢å¡çš®å·´æ‹‰</button>
                <div class="flex gap-1">
                    <button id="bandaid-btn" class="flex-1">ğŸ©¹ è²¼OKç¹ƒ</button>
                    <button id="eat-btn" class="flex-1">ğŸ´ åƒæ‰ç†Ÿæ°´è±š</button>
                </div>
                <div>
                    <label class="text-xs block mb-1">å ´æ™¯åˆ‡æ›ï¼š</label>
                    <select id="bg-select" class="w-full">
                        <option value="onsen">æº«æš–æº«æ³‰</option>
                        <option value="pool">æ¸…æ¶¼æ°´æ± </option>
                        <option value="land">é’é’è‰åœ°</option>
                        <option value="ar">é€è¦–æ¨¡å¼ (AR)</option>
                    </select>
                </div>
                <div class="flex gap-2">
                    <button id="reset-pos" class="flex-1 text-xs">é‡ç½®ä½ç½®</button>
                    <button id="reset-size" class="flex-1 text-xs">é‡ç½®å¤§å°</button>
                </div>
                <button id="hide-ui-btn" class="w-full border-dashed border-amber-500/50 mt-1 text-xs">éš±è—ä»‹é¢ä¸¦å…¨è¢å¹•</button>
            </div>
        </div>
    </div>

    <div id="info-tag">
        <div class="flex gap-4">
            <span>å¤–æ®¼é¢ç©: <span id="area-val">0</span> px</span>
            <span style="color: #f87171;">é£¢é¤“å€¼: <span id="hunger-val">0</span></span>
        </div>
        <div class="flex gap-4 text-[10px] opacity-80">
            <span>X: <span id="pos-x">0</span></span>
            <span>Y: <span id="pos-y">0</span></span>
        </div>
    </div>

    <div id="video-preview-container">
        <video id="input-video" class="hidden"></video>
        <canvas id="output-video-canvas" style="width: 100%; height: 100%;"></canvas>
    </div>

    <canvas id="game-canvas"></canvas>

    <footer>
        ç‰ˆæ¬Šæ‰€æœ‰ Â© 2026 <a href="https://pandapanda6666.github.io" target="_blank">PandaPandaçš„AIæ—¥å¸¸</a> All Rights Reserved.
    </footer>

    <script>
        const { Engine, Render, Runner, World, Bodies, Composite, Constraint, Events, Vector, Body } = Matter;

        const bgImages = { pool: '1.jpg', onsen: '2.jpg', land: '3.jpg' };
        const bgLayer = document.getElementById('background-layer');
        const arVideo = document.getElementById('ar-video');
        const steamOverlay = document.getElementById('steam-overlay');
        const bgSelect = document.getElementById('bg-select');
        const areaValLabel = document.getElementById('area-val');
        const hungerValLabel = document.getElementById('hunger-val');
        const posXVal = document.getElementById('pos-x');
        const posYVal = document.getElementById('pos-y');
        const startBtn = document.getElementById('start-camera-btn');
        const cameraSelect = document.getElementById('camera-select');
        const hideUiBtn = document.getElementById('hide-ui-btn');
        const showUiBtn = document.getElementById('show-ui-btn');
        const bandaidBtn = document.getElementById('bandaid-btn');
        const addCapybaraBtn = document.getElementById('add-capybara-btn');
        const eatBtn = document.getElementById('eat-btn');
        const controlCard = document.getElementById('control-card');
        const infoTag = document.getElementById('info-tag');

        const canvas = document.getElementById('game-canvas');
        const engine = Engine.create();
        const world = engine.world;
        
        // æé«˜ç‰©ç†å¼•æ“çš„è¿­ä»£æ¬¡æ•¸ä»¥ä¿è­‰è»Ÿé«”ç©©å®šæ€§
        engine.gravity.y = 1.6;
        engine.positionIterations = 15;
        engine.velocityIterations = 15;

        const render = Render.create({
            canvas: canvas, engine: engine,
            options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: 'transparent' }
        });

        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        let capybaras = [];
        let hungerValue = 0;

        function createCapybara(xx, yy) {
            const radius = 90;
            const segments = 32;
            const particles = [];
            
            // æ¯ä¸€éš»æ°´è±šæ“æœ‰ç¨ç‰¹çš„ç¢°æ’çµ„ï¼Œé¿å…å…§éƒ¨é›¶ä»¶äº’æ’ï¼Œä½†æœƒè·Ÿå…¶ä»–éš»ç¢°æ’
            const group = Body.nextGroup(true);

            // 1. æ”¯æ’å…§æ ¸ (Core) - é€™æ˜¯å‰›é«”å †ç–Šçš„é—œéµ
            const core = Bodies.circle(xx, yy, 45, {
                friction: 1.0,
                frictionStatic: 2.0,
                restitution: 0,
                collisionFilter: { group: group },
                render: { visible: false }
            });

            // 2. è»Ÿè³ªå¤–æ®¼ç²’å­ (Shell Particles)
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                particles.push(Bodies.circle(xx + Math.cos(angle) * radius, yy + Math.sin(angle) * radius, 10, {
                    friction: 1.0, 
                    frictionStatic: 2.0,
                    restitution: 0, 
                    density: 0.005,
                    collisionFilter: { group: group },
                    render: { visible: false }
                }));
            }

            const constraints = [];
            // 3. é€£æ¥ç²’å­å½¢æˆç’°ç‹€è’™çš®
            for (let i = 0; i < segments; i++) {
                constraints.push(Constraint.create({
                    bodyA: particles[i], bodyB: particles[(i + 1) % segments],
                    stiffness: 0.8, damping: 0.1, render: { visible: false }
                }));
            }

            // 4. éª¨æ¶ç´„æŸï¼šé€£æ¥ç²’å­èˆ‡æ ¸å¿ƒ
            particles.forEach(p => {
                constraints.push(Constraint.create({
                    bodyA: core, bodyB: p, 
                    stiffness: 0.25, // æ§åˆ¶ã€Œè»Ÿç¡¬åº¦ã€
                    damping: 0.2, 
                    render: { visible: false }
                }));
            });

            // 5. å¼·åŒ–äº¤å‰æ”¯æ’ï¼šé˜²æ­¢éåº¦æ‹‰é•·æˆ–æ‰­æ›²
            for (let i = 0; i < segments; i += 4) {
                const targetIdx = (i + Math.floor(segments / 2)) % segments;
                constraints.push(Constraint.create({
                    bodyA: particles[i], bodyB: particles[targetIdx],
                    stiffness: 0.1, render: { visible: false }
                }));
            }

            const composite = Composite.create({ bodies: [...particles, core], constraints });
            World.add(world, composite);
            
            const capy = {
                composite,
                particles,
                core,
                radius,
                roastedLevel: 0,
                bruises: []
            };
            capybaras.push(capy);
            return capy;
        }

        createCapybara(window.innerWidth / 2, window.innerHeight / 2);

        function setUiVisibility(visible) {
            if (visible) {
                controlCard.classList.remove('ui-hidden');
                infoTag.classList.remove('ui-hidden');
                showUiBtn.style.display = 'none';
                if (document.fullscreenElement) document.exitFullscreen().catch(e => {});
            } else {
                controlCard.classList.add('ui-hidden');
                infoTag.classList.add('ui-hidden');
                showUiBtn.style.display = 'block';
                if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e => {});
            }
        }

        hideUiBtn.onclick = () => setUiVisibility(false);
        showUiBtn.onclick = () => setUiVisibility(true);

        async function getCameras() {
            try {
                await navigator.mediaDevices.getUserMedia({ video: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                cameraSelect.innerHTML = '';
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `æ”å½±æ©Ÿ ${index + 1}`;
                    cameraSelect.appendChild(option);
                });
            } catch (err) { console.error(err); }
        }
        getCameras();

        cameraSelect.onchange = async () => {
            if (cameraInstance) { await cameraInstance.stop(); cameraInstance = null; }
            startBtn.innerText = "å•Ÿå‹•æ”å½±æ©Ÿ";
            startBtn.disabled = false;
        };

        function updateBackground() {
            const mode = bgSelect.value;
            arVideo.style.display = 'none'; steamOverlay.style.display = 'none'; bgLayer.style.backgroundImage = 'none';
            if (mode === 'ar') { 
                arVideo.style.display = 'block';
                if (cameraInstance) arVideo.srcObject = videoElement.srcObject;
            } else { 
                bgLayer.style.backgroundImage = `url('${bgImages[mode]}')`; 
                if (mode === 'onsen') steamOverlay.style.display = 'block'; 
            }
        }
        bgSelect.addEventListener('change', updateBackground);

        let currentWalls = [];
        function createWalls() {
            if (currentWalls.length > 0) World.remove(world, currentWalls);
            const opt = { isStatic: true, friction: 1.0, frictionStatic: 5, restitution: 0, render: { visible: false } };
            const W = window.innerWidth, H = window.innerHeight;
            const groundY = H * 0.9;

            currentWalls = [
                Bodies.rectangle(W / 2, groundY + 300, W + 2000, 600, opt),
                Bodies.rectangle(W / 2, -300, W + 2000, 600, opt),
                Bodies.rectangle(-300, H / 2, 600, H + 2000, opt),
                Bodies.rectangle(W + 300, H / 2, 600, H + 2000, opt)
            ];
            World.add(world, currentWalls);
        }
        createWalls();

        addCapybaraBtn.onclick = () => {
            createCapybara(window.innerWidth / 2 + (Math.random()-0.5)*20, 100);
        };

        bandaidBtn.onclick = () => {
            capybaras.forEach(c => {
                const target = c.bruises.find(b => !b.hasBandaid);
                if (target) target.hasBandaid = true;
            });
        };

        eatBtn.onclick = () => {
            const sorted = [...capybaras].sort((a, b) => b.roastedLevel - a.roastedLevel);
            if (sorted.length > 0 && sorted[0].roastedLevel > 80) {
                const target = sorted[0];
                World.remove(world, target.composite);
                capybaras = capybaras.filter(c => c !== target);
                hungerValue += 20; 
                hungerValLabel.innerText = hungerValue;
            }
        };

        document.getElementById('reset-pos').onclick = () => {
            capybaras.forEach((c, idx) => {
                const targetY = window.innerHeight / 2 - (idx * 160);
                Body.setPosition(c.core, { x: window.innerWidth / 2, y: targetY });
                c.particles.forEach(p => Body.setPosition(p, { x: window.innerWidth / 2, y: targetY }));
                Body.setVelocity(c.core, { x: 0, y: 0 });
            });
        };

        document.getElementById('reset-size').onclick = () => {
            capybaras.forEach(c => {
                const cx = c.core.position.x, cy = c.core.position.y;
                c.particles.forEach((p, i) => {
                    const a = (i / c.particles.length) * Math.PI * 2;
                    Body.setPosition(p, { x: cx + Math.cos(a) * c.radius, y: cy + Math.sin(a) * c.radius });
                });
            });
        };

        Events.on(engine, 'afterUpdate', () => {
            const W = window.innerWidth, H = window.innerHeight;
            const roastX = W - 150, roastY = H - 120;

            capybaras.forEach(c => {
                if (c.core.position.y > H + 500) Body.setPosition(c.core, { x: W/2, y: 100 });

                const distToFire = Math.hypot(c.core.position.x - roastX, c.core.position.y - roastY);
                if (distToFire < 130) c.roastedLevel = Math.min(100, c.roastedLevel + 0.3);
                
                // è‡ªå‹•ä¿®æ­£å€’ç«‹çš„æƒ…å½¢ï¼Œä¿æŒç«™å§¿åˆ©æ–¼å †ç–Š
                if (Math.abs(c.core.angle) > 0.8) {
                    Body.setAngularVelocity(c.core, -c.core.angle * 0.05);
                }

                // è¨ˆç®—é¢ç©é¡¯ç¤º
                if (c === capybaras[0]) {
                    let a = 0;
                    for (let i = 0; i < c.particles.length; i++) {
                        const p1 = c.particles[i].position, p2 = c.particles[(i+1)%c.particles.length].position;
                        a += (p1.x * p2.y) - (p2.x * p1.y);
                    }
                    areaValLabel.innerText = Math.round(Math.abs(a) * 0.5);
                    posXVal.innerText = Math.round(c.core.position.x);
                    posYVal.innerText = Math.round(c.core.position.y);
                }
            });
        });

        const videoElement = document.getElementById('input-video');
        const videoPreviewCtx = document.getElementById('output-video-canvas').getContext('2d');
        let lastResults = null, cameraInstance = null;
        const activePinches = new Map();

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        
        hands.onResults((results) => {
            lastResults = results;
            videoPreviewCtx.save();
            videoPreviewCtx.clearRect(0, 0, 200, 150);
            videoPreviewCtx.drawImage(results.image, 0, 0, 200, 150);
            videoPreviewCtx.restore();

            if (results.multiHandLandmarks) {
                const W = window.innerWidth, H = window.innerHeight;
                const activeIndices = new Set();

                results.multiHandLandmarks.forEach((lms, handIdx) => {
                    activeIndices.add(handIdx);
                    const thumb = { x: (1 - lms[4].x) * W, y: lms[4].y * H };
                    const indexF = { x: (1 - lms[8].x) * W, y: lms[8].y * H };
                    const pinchPos = (Math.hypot(thumb.x - indexF.x, thumb.y - indexF.y) < 55) ? { x: (thumb.x + indexF.x)/2, y: (thumb.y + indexF.y)/2 } : null;

                    if (pinchPos) {
                        if (!activePinches.has(handIdx)) {
                            let closestParticle = null, minDist = 120;
                            capybaras.forEach(c => {
                                c.particles.forEach(p => {
                                    const d = Math.hypot(p.position.x - pinchPos.x, p.position.y - pinchPos.y);
                                    if (d < minDist) { minDist = d; closestParticle = p; }
                                });
                            });
                            if (closestParticle) {
                                // æä½å¤–æ®¼ç²’å­è€Œéæ ¸å¿ƒï¼Œé€™æ¨£æ‰èƒ½ç”¢ç”Ÿå±€éƒ¨æ‹‰æ‰¯å½¢è®Š
                                const cns = Constraint.create({ 
                                    pointA: pinchPos, 
                                    bodyB: closestParticle, 
                                    stiffness: 0.5, 
                                    damping: 0.5,
                                    render: { visible: true, strokeStyle: '#fbbf24', lineWidth: 3 } 
                                });
                                World.add(world, cns);
                                activePinches.set(handIdx, { constraint: cns });
                            }
                        } else { 
                            activePinches.get(handIdx).constraint.pointA = pinchPos; 
                        }
                    } else if (activePinches.has(handIdx)) {
                        World.remove(world, activePinches.get(handIdx).constraint);
                        activePinches.delete(handIdx);
                    }
                });
                for (let k of activePinches.keys()) if (!activeIndices.has(k)) { World.remove(world, activePinches.get(k).constraint); activePinches.delete(k); }
            } else {
                activePinches.forEach(v => World.remove(world, v.constraint)); activePinches.clear();
            }
        });

        startBtn.onclick = async () => {
            const deviceId = cameraSelect.value; if (!deviceId) return;
            startBtn.innerText = "æ­£åœ¨å•Ÿå‹•..."; startBtn.disabled = true;
            if (cameraInstance) await cameraInstance.stop();
            cameraInstance = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480, deviceId
            });
            await cameraInstance.start();
            if (bgSelect.value === 'ar') arVideo.srcObject = videoElement.srcObject;
            startBtn.innerText = "æ”å½±æ©Ÿå·²é€£ç·š"; startBtn.style.animation = 'none'; startBtn.style.background = '#4ade80';
        };

        Events.on(render, 'afterRender', () => {
            const ctx = render.context, W = window.innerWidth, H = window.innerHeight;

            // ç¹ªè£½ç«å †
            const rx = W - 150, ry = H - 120;
            ctx.save();
            ctx.fillStyle = 'rgba(255, 69, 0, 0.15)';
            ctx.beginPath(); ctx.arc(rx, ry, 100, 0, Math.PI*2); ctx.fill();
            const time = Date.now() * 0.01;
            for(let i=0; i<3; i++) {
                ctx.font = `${40 + Math.sin(time + i)*10}px serif`;
                ctx.fillText('ğŸ”¥', rx - 35 + i*25, ry + 15 + Math.cos(time + i)*10);
            }
            ctx.restore();

            // ç¹ªè£½æ°´è±šè’™çš®
            capybaras.forEach(c => {
                const pts = c.particles, center = c.core.position;
                
                ctx.beginPath();
                ctx.moveTo(pts[0].position.x, pts[0].position.y);
                for(let i=1; i<pts.length; i++) {
                    ctx.lineTo(pts[i].position.x, pts[i].position.y);
                }
                ctx.closePath();

                const level = c.roastedLevel;
                const r = Math.floor(161 - level * 1.3), g = Math.floor(98 - level * 0.9), b = Math.floor(7 - level * 0.05);
                const grad = ctx.createRadialGradient(center.x, center.y - 15, 10, center.x, center.y, c.radius * 1.2);
                grad.addColorStop(0, `rgb(${r+30}, ${g+30}, ${b})`);
                grad.addColorStop(1, `rgb(${r}, ${g}, ${b})`);
                
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.strokeStyle = '#452205';
                ctx.lineWidth = 4;
                ctx.stroke();

                // è‡‰éƒ¨ç´°ç¯€ (åŸºæ–¼æ ¸å¿ƒåº§æ¨™èˆ‡ç¬¬ä¸€å€‹ç²’å­çš„æ–¹å‘ç¹ªè£½)
                const angle = Math.atan2(pts[0].position.y - center.y, pts[0].position.x - center.x);
                ctx.save();
                ctx.translate(center.x, center.y);
                ctx.rotate(angle);
                
                // è€³æœµ
                const drawEar = (s) => {
                    ctx.fillStyle = '#713f12'; ctx.beginPath();
                    ctx.arc(s * 40, -c.radius + 15, 16, 0, Math.PI*2);
                    ctx.fill(); ctx.stroke();
                };
                drawEar(-1); drawEar(1);

                // è‡‰éƒ¨
                ctx.fillStyle = '#854d0e'; ctx.beginPath(); ctx.roundRect(-30, 0, 60, 25, 10); ctx.fill();
                ctx.fillStyle = '#29180c'; ctx.beginPath(); ctx.arc(-7, 15, 3, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(7, 15, 3, 0, Math.PI*2); ctx.fill();
                
                // çœ‰æ¯›
                ctx.strokeStyle = '#1c1917'; ctx.lineWidth = 3; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(-25, -10); ctx.lineTo(-15, -8); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(25, -10); ctx.lineTo(15, -8); ctx.stroke();
                
                ctx.restore();

                // æ©˜å­ï¼ˆè·Ÿéš¨æœ€é ‚ç«¯çš„ç²’å­ï¼‰
                let topP = pts[0]; pts.forEach(p => { if(p.position.y < topP.position.y) topP = p; });
                ctx.fillStyle = '#f97316'; ctx.beginPath(); ctx.arc(topP.position.x, topP.position.y - 15, 16, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#16a34a'; ctx.beginPath(); ctx.ellipse(topP.position.x, topP.position.y - 30, 8, 4, Math.PI/4, 0, Math.PI*2); ctx.fill();
            });

            // æ‰‹éƒ¨éª¨æ¶
            if (lastResults && lastResults.multiHandLandmarks) {
                lastResults.multiHandLandmarks.forEach(lms => {
                    ctx.strokeStyle = 'rgba(251, 191, 36, 0.4)'; ctx.lineWidth = 3;
                    HAND_CONNECTIONS.forEach(([s, e]) => {
                        ctx.beginPath(); ctx.moveTo((1 - lms[s].x) * W, lms[s].y * H); ctx.lineTo((1 - lms[e].x) * W, lms[e].y * H); ctx.stroke();
                    });
                });
            }
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            render.options.width = window.innerWidth; render.options.height = window.innerHeight;
            createWalls();
        });
        setTimeout(() => { document.getElementById('reset-pos').onclick(); }, 1000);
    </script>
</body>
</html>
