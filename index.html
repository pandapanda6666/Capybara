<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>捏卡皮巴拉...</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: sans-serif;
        }
        #background-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: background-image 0.5s ease;
        }
        #ar-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: -2;
            transform: scaleX(-1);
            display: none;
        }
        #steam-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(2px);
            pointer-events: none;
            z-index: 1;
            display: none;
        }
        #video-preview-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid #fbbf24;
            border-radius: 12px;
            overflow: hidden;
            z-index: 100;
            transform: scaleX(-1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            display: none;
        }
        #game-canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            position: relative;
            z-index: 10;
        }
        .ui-overlay {
            position: fixed;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 110;
        }
        .status-card {
            background: rgba(41, 37, 36, 0.9);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 16px;
            border-left: 6px solid #fbbf24;
            pointer-events: auto;
            max-width: 320px;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        .control-group {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        select, button {
            background: #44403c;
            color: #fde68a;
            border: 1px solid #57534e;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        select:hover, button:hover {
            background: #57534e;
        }
        #area-tag {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.6);
            padding: 5px 12px;
            border-radius: 20px;
            font-family: monospace;
            color: #fbbf24;
            z-index: 110;
            transition: opacity 0.3s ease;
            display: flex;
            gap: 10px;
        }
        .instruction-box {
            background: rgba(28, 25, 23, 0.6);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }
        .instruction-item {
            font-size: 13px;
            color: #fde68a;
            margin-bottom: 4px;
        }
        #start-camera-btn {
            background: #fbbf24;
            color: #1c1917;
            font-weight: bold;
            padding: 12px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(251, 191, 36, 0); }
            100% { box-shadow: 0 0 0 0 rgba(251, 191, 36, 0); }
        }
        .ui-hidden {
            opacity: 0 !important;
            pointer-events: none !important;
            transform: translateX(-20px);
        }
        #show-ui-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 120;
            background: rgba(41, 37, 36, 0.8);
            color: #fbbf24;
            border: 1px solid #fbbf24;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            display: none;
            cursor: pointer;
        }
        footer {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            z-index: 110;
            color: rgba(255,255,255,0.7);
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
            transition: opacity 0.3s ease;
        }
        footer a { color: #fbbf24; text-decoration: none; font-weight: bold; }
    </style>
</head>
<body>

    <div id="background-layer"></div>
    <video id="ar-video" autoplay playsinline></video>
    <div id="steam-overlay"></div>

    <button id="show-ui-btn">顯示選單</button>

    <div class="ui-overlay" id="main-ui">
        <div class="status-card" id="control-card">
            <h1 class="text-xl font-bold text-amber-400 mb-1">捏卡皮巴拉...</h1>
            
            <div id="camera-setup-area" class="mb-3">
                <label class="text-xs block mb-1 text-amber-100">選擇攝影機：</label>
                <select id="camera-select" class="w-full mb-2">
                    <option value="">正在載入鏡頭...</option>
                </select>
                <button id="start-camera-btn" class="w-full rounded-lg">啟動攝影機</button>
            </div>

            <div class="instruction-box">
                <p class="text-xs font-bold text-amber-200 mb-2">遊戲說明：</p>
                <div class="instruction-item">● 隨機捏合：指尖靠近拇指即可抓取</div>
                <div class="instruction-item">● 實體按壓：手指靠近臉部進行揉搓</div>
                <div class="instruction-item">● 自動全螢幕：隱藏介面時進入沉浸模式</div>
                <div class="instruction-item">● 貼合頭頂：耳朵精確貼合身體外邊緣</div>
            </div>
            
            <div class="control-group">
                <div>
                    <label class="text-xs block mb-1">場景切換：</label>
                    <select id="bg-select" class="w-full">
                        <option value="onsen">溫暖溫泉</option>
                        <option value="pool">清涼水池</option>
                        <option value="land">青青草地</option>
                        <option value="ar">透視模式</option>
                    </select>
                </div>
                <div class="flex items-center gap-2">
                    <input type="checkbox" id="cam-toggle">
                    <label for="cam-toggle" class="text-xs cursor-pointer">顯示相機小窗</label>
                </div>
                <div class="flex gap-2">
                    <button id="reset-pos" class="flex-1">重置位置</button>
                    <button id="reset-size" class="flex-1">重置大小</button>
                </div>
                <button id="hide-ui-btn" class="w-full border-dashed border-amber-500/50 mt-1">隱藏所有介面</button>
            </div>
        </div>
    </div>

    <div id="area-tag">
        <span>面積: <span id="area-val">0</span> px</span>
        <span>X: <span id="pos-x">0</span></span>
        <span>Y: <span id="pos-y">0</span></span>
    </div>

    <div id="video-preview-container">
        <video id="input-video" class="hidden"></video>
        <canvas id="output-video-canvas" style="width: 100%; height: 100%;"></canvas>
    </div>

    <canvas id="game-canvas"></canvas>

    <footer id="game-footer">
        版權所有 © 2026 <a href="https://pandapanda6666.github.io" target="_blank">PandaPanda的AI日常</a> All Rights Reserved.
    </footer>

    <script>
        const { Engine, Render, Runner, World, Bodies, Composite, Constraint, Events, Vector, Body } = Matter;

        const bgImages = {
            pool: 'https://www.ritagiang.com/files/articleFilesfinder/images/20150613_134817-1.jpg',
            onsen: 'https://images.storm.mg/gallery/201145/20190212-102833_U7321_M497924_6eda.jpg',
            land: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQedVDhKZfVjOlORwYqk1pqjnTo9elRJLHM1A&s'
        };

        const bgLayer = document.getElementById('background-layer');
        const arVideo = document.getElementById('ar-video');
        const steamOverlay = document.getElementById('steam-overlay');
        const bgSelect = document.getElementById('bg-select');
        const camToggle = document.getElementById('cam-toggle');
        const camPreview = document.getElementById('video-preview-container');
        const areaVal = document.getElementById('area-val');
        const posXVal = document.getElementById('pos-x');
        const posYVal = document.getElementById('pos-y');
        const startBtn = document.getElementById('start-camera-btn');
        const cameraSelect = document.getElementById('camera-select');
        const hideUiBtn = document.getElementById('hide-ui-btn');
        const showUiBtn = document.getElementById('show-ui-btn');
        const controlCard = document.getElementById('control-card');
        const areaTag = document.getElementById('area-tag');
        const footer = document.getElementById('game-footer');

        const canvas = document.getElementById('game-canvas');
        const engine = Engine.create();
        const world = engine.world;
        engine.gravity.y = 1.0;

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: 'transparent'
            }
        });

        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        function setUiVisibility(visible) {
            if (visible) {
                controlCard.classList.remove('ui-hidden');
                areaTag.classList.remove('ui-hidden');
                footer.classList.remove('ui-hidden');
                showUiBtn.style.display = 'none';
                // 恢復 UI 時嘗試退出全螢幕
                if (document.fullscreenElement) {
                    document.exitFullscreen().catch(err => {});
                }
            } else {
                controlCard.classList.add('ui-hidden');
                areaTag.classList.add('ui-hidden');
                footer.classList.add('ui-hidden');
                showUiBtn.style.display = 'block';
                // 隱藏 UI 時進入全螢幕
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {});
                }
            }
        }

        hideUiBtn.onclick = () => setUiVisibility(false);
        showUiBtn.onclick = () => setUiVisibility(true);

        async function getCameras() {
            try {
                await navigator.mediaDevices.getUserMedia({ video: true });
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                cameraSelect.innerHTML = '';
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `攝影機 ${index + 1}`;
                    cameraSelect.appendChild(option);
                });
            } catch (err) {
                console.error("無法列出攝影機:", err);
                cameraSelect.innerHTML = '<option value="">無法偵測攝影機</option>';
            }
        }
        getCameras();

        function updateBackground() {
            const mode = bgSelect.value;
            arVideo.style.display = 'none';
            steamOverlay.style.display = 'none';
            bgLayer.style.backgroundImage = 'none';
            if (mode === 'ar') {
                arVideo.style.display = 'block';
            } else {
                bgLayer.style.backgroundImage = `url('${bgImages[mode]}')`;
                if (mode === 'onsen') steamOverlay.style.display = 'block';
            }
        }
        bgSelect.addEventListener('change', updateBackground);
        bgSelect.value = 'onsen';
        updateBackground();

        camToggle.addEventListener('change', () => {
            camPreview.style.display = camToggle.checked ? 'block' : 'none';
        });

        let currentWalls = [];
        const wallThickness = 600;
        function createWalls() {
            if (currentWalls.length > 0) World.remove(world, currentWalls);
            const opt = { isStatic: true, friction: 0.5, restitution: 0.7, render: { visible: false } };
            const W = window.innerWidth, H = window.innerHeight;
            currentWalls = [
                Bodies.rectangle(W / 2, H + wallThickness / 2, W + 2000, wallThickness, opt),
                Bodies.rectangle(W / 2, -wallThickness / 2, W + 2000, wallThickness, opt),
                Bodies.rectangle(-wallThickness / 2, H / 2, wallThickness, H + 2000, opt),
                Bodies.rectangle(W + wallThickness / 2, H / 2, wallThickness, H + 2000, opt)
            ];
            World.add(world, currentWalls);
        }
        createWalls();

        function createCapybaraBall(xx, yy, radius, segments) {
            const particles = [];
            for (let i = 0; i < segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                particles.push(Bodies.circle(xx + Math.cos(angle) * radius, yy + Math.sin(angle) * radius, 7, {
                    friction: 0.5, restitution: 0.8, render: { visible: false }
                }));
            }
            const constraints = [];
            for (let i = 0; i < segments; i++) {
                constraints.push(Constraint.create({
                    bodyA: particles[i], bodyB: particles[(i + 1) % segments],
                    stiffness: 0.9, damping: 0.05, render: { visible: false }
                }));
            }
            const center = Bodies.circle(xx, yy, 25, { isSensor: true, render: { visible: false } });
            particles.forEach(p => {
                constraints.push(Constraint.create({
                    bodyA: center, bodyB: p, stiffness: 0.22, damping: 0.1, render: { visible: false }
                }));
            });
            const composite = Composite.create({ bodies: [...particles, center], constraints });
            World.add(world, composite);
            return { particles, center, radius, composite };
        }

        let ball = createCapybaraBall(window.innerWidth / 2, window.innerHeight / 2, 140, 40);

        function resetPosition() {
            const xx = window.innerWidth / 2, yy = window.innerHeight / 2;
            const dx = xx - ball.center.position.x, dy = yy - ball.center.position.y;
            Body.setPosition(ball.center, { x: xx, y: yy });
            ball.particles.forEach(p => Body.setPosition(p, { x: p.position.x + dx, y: p.position.y + dy }));
        }

        function resetSize() {
            const cx = ball.center.position.x, cy = ball.center.position.y;
            const a0 = Math.atan2(ball.particles[0].position.y - cy, ball.particles[0].position.x - cx);
            ball.particles.forEach((p, i) => {
                const a = a0 + (i / ball.particles.length) * Math.PI * 2;
                Body.setPosition(p, { x: cx + Math.cos(a) * ball.radius, y: cy + Math.sin(a) * ball.radius });
                Body.setVelocity(p, { x: 0, y: 0 });
            });
            Body.setVelocity(ball.center, { x: 0, y: 0 });
        }

        document.getElementById('reset-pos').onclick = resetPosition;
        document.getElementById('reset-size').onclick = resetSize;

        Events.on(engine, 'afterUpdate', () => {
            const W = window.innerWidth, H = window.innerHeight;
            const pad = 20, minR = 25; 

            const maxYLimit = H * 0.875;
            const resetYTarget = H * 0.8125;

            if (ball.center.position.y > maxYLimit) {
                const dy = resetYTarget - ball.center.position.y;
                Body.setPosition(ball.center, { x: ball.center.position.x, y: resetYTarget });
                ball.particles.forEach(p => {
                    Body.setPosition(p, { x: p.position.x, y: p.position.y + dy });
                });
            }

            ball.particles.forEach(p => {
                const dx = p.position.x - ball.center.position.x, dy = p.position.y - ball.center.position.y;
                const d = Math.hypot(dx, dy);
                if (d < minR) {
                    const a = Math.atan2(dy, dx);
                    Body.setPosition(p, { x: ball.center.position.x + Math.cos(a) * minR, y: ball.center.position.y + Math.sin(a) * minR });
                }
                let x = p.position.x, y = p.position.y;
                if (x < pad) x = pad; if (x > W - pad) x = W - pad;
                if (y < pad) y = pad; if (y > H - pad) y = H - pad;
                if (x !== p.position.x || y !== p.position.y) Body.setPosition(p, { x, y });
            });
            let area = 0;
            const pts = ball.particles;
            for (let i = 0; i < pts.length; i++) {
                area += (pts[i].position.x * pts[(i + 1) % pts.length].position.y) - (pts[(i + 1) % pts.length].position.x * pts[i].position.y);
            }
            area = Math.abs(area) * 0.5;
            areaVal.innerText = Math.round(area);
            
            posXVal.innerText = Math.round(ball.center.position.x);
            posYVal.innerText = Math.round(ball.center.position.y);

            if (area < 10000) resetSize();
        });

        const videoElement = document.getElementById('input-video');
        const videoPreviewCtx = document.getElementById('output-video-canvas').getContext('2d');
        let lastResults = null, activePinch = null, cameraInstance = null;

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.75, minTrackingConfidence: 0.75 });
        hands.onResults((results) => {
            lastResults = results;
            videoPreviewCtx.save();
            videoPreviewCtx.clearRect(0, 0, 200, 150);
            videoPreviewCtx.drawImage(results.image, 0, 0, 200, 150);
            videoPreviewCtx.restore();
            if (bgSelect.value === 'ar' && arVideo.srcObject !== videoElement.srcObject) arVideo.srcObject = videoElement.srcObject;
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lms = results.multiHandLandmarks[0];
                const W = window.innerWidth, H = window.innerHeight;
                const getPx = (i) => ({ x: (1 - lms[i].x) * W, y: lms[i].y * H });
                const thumb = getPx(4), tips = [8, 12, 16, 20].map(getPx);
                let pinchPos = null;
                tips.forEach(t => { if (Math.hypot(thumb.x - t.x, thumb.y - t.y) < 55) pinchPos = { x: (thumb.x + t.x)/2, y: (thumb.y + t.y)/2 }; });
                if (pinchPos) {
                    if (!activePinch) {
                        let closest = null, minDist = 160;
                        ball.particles.forEach(p => {
                            const d = Math.hypot(p.position.x - pinchPos.x, p.position.y - pinchPos.y);
                            if (d < minDist) { minDist = d, closest = p; }
                        });
                        if (closest) {
                            activePinch = Constraint.create({ pointA: pinchPos, bodyB: closest, stiffness: 0.35, render: { visible: true, strokeStyle: '#fbbf24', lineWidth: 3 } });
                            World.add(world, activePinch);
                        }
                    } else activePinch.pointA = pinchPos;
                } else if (activePinch) { World.remove(world, activePinch); activePinch = null; }
                [4, 8, 12, 16, 20].map(getPx).forEach(tip => {
                    ball.particles.forEach(p => {
                        const d = Math.hypot(p.position.x - tip.x, p.position.y - tip.y);
                        if (d < 110) {
                            const a = Math.atan2(p.position.y - tip.y, p.position.x - tip.x);
                            Body.applyForce(p, p.position, { x: Math.cos(a) * 0.025 * (1 - d/110), y: Math.sin(a) * 0.025 * (1 - d/110) });
                        }
                    });
                });
            } else if (activePinch) { World.remove(world, activePinch); activePinch = null; }
        });

        async function runCamera() {
            const deviceId = cameraSelect.value;
            if (!deviceId) return;
            startBtn.innerText = "正在啟動...";
            startBtn.disabled = true;
            if (cameraInstance) await cameraInstance.stop();
            try {
                cameraInstance = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: 640, height: 480, deviceId: deviceId
                });
                await cameraInstance.start();
                startBtn.innerText = "攝影機已連線";
                startBtn.style.animation = 'none';
                startBtn.style.background = '#4ade80';
            } catch (err) {
                console.error("無法開啟攝影機:", err);
                startBtn.innerText = "連線失敗，請重試";
                startBtn.disabled = false;
            }
        }
        startBtn.onclick = runCamera;
        cameraSelect.onchange = () => { if (cameraInstance) runCamera(); };

        Events.on(render, 'afterRender', () => {
            const ctx = render.context, pts = ball.particles, center = ball.center.position;
            const W = window.innerWidth, H = window.innerHeight;

            ctx.beginPath();
            ctx.moveTo(pts[0].position.x, pts[0].position.y);
            for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].position.x, pts[i].position.y);
            ctx.closePath();
            const grad = ctx.createRadialGradient(center.x, center.y - 30, 20, center.x, center.y, ball.radius * 1.3);
            grad.addColorStop(0, '#a16207'); grad.addColorStop(1, '#713f12');
            ctx.fillStyle = grad; ctx.fill();
            ctx.strokeStyle = '#452205'; ctx.lineWidth = 5; ctx.stroke();

            const bAngle = Math.atan2(pts[0].position.y - center.y, pts[0].position.x - center.x);

            ctx.save();
            ctx.translate(center.x, center.y);
            ctx.rotate(bAngle);

            const drawEar = (side) => {
                ctx.fillStyle = '#713f12';
                ctx.beginPath();
                ctx.arc(side * 55, -135, 18, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#452205'; ctx.lineWidth = 3;
                ctx.stroke();
            };
            drawEar(-1);
            drawEar(1);

            ctx.fillStyle = '#854d0e';
            ctx.beginPath();
            ctx.roundRect(-45, 5, 90, 35, 15);
            ctx.fill();

            ctx.fillStyle = '#29180c';
            ctx.beginPath(); ctx.arc(-10, 25, 4, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(10, 25, 4, 0, Math.PI * 2); ctx.fill();

            ctx.strokeStyle = '#1c1917'; ctx.lineWidth = 4; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(-35, -15); ctx.lineTo(-20, -12); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(35, -15); ctx.lineTo(20, -12); ctx.stroke();
            
            ctx.restore();

            let topP = pts[0]; pts.forEach(p => { if (p.position.y < topP.position.y) topP = p; });
            const ox = topP.position.x, oy = topP.position.y - 12;
            ctx.fillStyle = '#f97316';
            ctx.beginPath(); ctx.arc(ox, oy, 18, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#c2410c'; ctx.lineWidth = 2; ctx.stroke();
            ctx.fillStyle = '#16a34a';
            ctx.beginPath(); ctx.ellipse(ox, oy - 18, 10, 5, Math.PI/4, 0, Math.PI * 2); ctx.fill();

            if (lastResults && lastResults.multiHandLandmarks) {
                lastResults.multiHandLandmarks.forEach(lms => {
                    ctx.strokeStyle = 'rgba(251, 191, 36, 0.4)'; ctx.lineWidth = 4;
                    HAND_CONNECTIONS.forEach(([s, e]) => {
                        ctx.beginPath(); ctx.moveTo((1 - lms[s].x) * W, lms[s].y * H); ctx.lineTo((1 - lms[e].x) * W, lms[e].y * H); ctx.stroke();
                    });
                    lms.forEach(lm => {
                        ctx.beginPath(); ctx.arc((1 - lm.x) * W, lm.y * H, 5, 0, Math.PI * 2); ctx.fillStyle = '#fff'; ctx.fill();
                    });
                });
            }
        });

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth; canvas.height = window.innerHeight;
            render.options.width = window.innerWidth; render.options.height = window.innerHeight;
            createWalls(); resetPosition();
        });

        setTimeout(resetPosition, 100);
        setTimeout(resetPosition, 500);
        setTimeout(resetSize, 500);
    </script>
</body>
</html>
